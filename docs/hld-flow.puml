@startuml HLD-Flow-Blocks
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml

LAYOUT_LEFT_RIGHT()
HIDE_STEREOTYPE()
title Processamento de Video - Pipeline Streaming com Fan-out

legend right
  |= Cor |= Tipo |
  | <#438DD5> | AWS Services |
  | <#1168BD> | API / Backend |
  | <#999999> | Kubernetes |
  | <#FF9900> | Banco de Dados |
endlegend

Person(user, "Usuario", "Envia videos para processamento")

System_Boundary(block_auth, "BLOCO A - Autenticacao") {
  Container(cognito_A, "Cognito", "AWS", "Auth OTP")
}
Rel(user, cognito_A, "0. Login OTP")
Rel(cognito_A, user, "JWT")

System_Boundary(block_upload, "BLOCO B - Upload / API") {
  Container(apiVideos_B, "POST /videos", "Elysia", "Cria video")
  Container(apiUrls_B, "GET /upload-urls", "Elysia", "Batch 20 URLs")
  Container(apiParts_B, "POST /parts/{n}", "Elysia", "Reporta ETag")
  Container(apiComplete_B, "POST /complete", "Elysia", "Finaliza upload")
  ContainerDb(s3Videos_B, "S3 Videos", "S3", "Videos originais")
  ContainerDb(s3Frames_B, "S3 Frames", "S3", "Frames extraidos")
  ContainerDb(cassandra_B, "ScyllaDB", "CQL", "Status video")
}

Rel(user, apiVideos_B, "1. Cria video")
Rel(apiVideos_B, s3Videos_B, "CreateMultipartUpload")
Rel(apiVideos_B, cassandra_B, "CREATED")

Rel(user, apiUrls_B, "2. Solicita URLs (batch 20)")
Rel(apiUrls_B, s3Videos_B, "getSignedUrl")
Rel(apiUrls_B, cassandra_B, "UPLOADING")

Rel(user, s3Videos_B, "3. Upload partes direto")
Rel(user, apiParts_B, "4. Reporta ETag")
Rel(apiParts_B, cassandra_B, "Atualiza parte")

Rel(user, apiComplete_B, "5. Finaliza")
Rel(apiComplete_B, s3Videos_B, "CompleteMultipart")

System_Boundary(block_events, "BLOCO C - Event Bus / SQS") {
  Container(eventbridge_C, "EventBridge", "AWS", "Roteamento de eventos")
  ContainerQueue(sqsMultipart_C, "SQS Multipart", "SQS", "Eventos S3 Complete")
  Container(apiConsumer_C, "API Consumer", "Elysia", "Processa eventos S3")
  Container(apiDestSES_C, "API Destination", "EB", "Notificacao SES")
  ContainerQueue(sqsOrch_C, "SQS Orchestrator", "SQS", "Fila orquestracao")
  ContainerQueue(sqsPrint_C, "SQS Print", "SQS", "Fila print (fan-out)")
}

Rel(s3Videos_B, eventbridge_C, "6. Object Created")
Rel(eventbridge_C, sqsMultipart_C, "Enfileira")
Rel(sqsMultipart_C, apiConsumer_C, "Poll")
Rel(apiConsumer_C, cassandra_B, "UPLOADED")
Rel(apiConsumer_C, eventbridge_C, "7. Video Status Changed")
Rel(eventbridge_C, sqsOrch_C, "Enfileira")

System_Boundary(block_orch, "BLOCO D - Orchestrator (Fan-out)") {
  Container(kedaOrch_D, "Orchestrator Worker", "KEDA", "Consome SQS")
  Container(jobOrch_D, "Calcula Ranges", "Bun", "duration / 10s = N ranges")
}

Rel(sqsOrch_C, kedaOrch_D, "8. Poll")
Rel(kedaOrch_D, jobOrch_D, "Processa evento")
Rel(jobOrch_D, sqsPrint_C, "9. Publica N mensagens")

System_Boundary(block_print, "BLOCO E - Print Workers (Paralelo)") {
  Container(kedaPrint_E, "Print Workers (N)", "KEDA", "Consome SQS paralelo")
  Container(jobPrint_E, "FFmpeg Print", "Bun", "Extrai frames via HTTP Range")
  ContainerDb(s3Frames_E, "S3 Frames", "S3", "Salva frames")
  ContainerDb(cassandra_E, "ScyllaDB", "CQL", "Progresso")
}

Rel(sqsPrint_C, kedaPrint_E, "10. Poll (N workers)")
Rel(kedaPrint_E, jobPrint_E, "Processa range")
Rel(jobPrint_E, s3Videos_B, "HTTP Range Request")
Rel(jobPrint_E, s3Frames_E, "Salva frames")
Rel(jobPrint_E, cassandra_E, "Atualiza progresso")
Rel(jobPrint_E, eventbridge_C, "11. Status Changed (ultimo)")

System_Boundary(block_notify, "BLOCO F - Notificacoes (SES - Zero Lambda)") {
  Container(apiDestSES_F, "API Destination", "EB", "Notificacao SES")
  Container(ses_F, "SES", "AWS", "Email Templates")
}

Rel(eventbridge_C, apiDestSES_F, "Roteia notificacao")
Rel(apiDestSES_F, ses_F, "12. SendTemplatedEmail")
Rel_Back(ses_F, user, "Email: Concluido / Falha")

@enduml
