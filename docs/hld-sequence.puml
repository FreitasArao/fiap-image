@startuml HLD-Sequence
!theme aws-orange

title Processamento de Video - Pipeline Streaming com Fan-out\n(EventBridge + SQS + KEDA + SES)

skinparam backgroundColor #FEFEFE
skinparam sequenceArrowThickness 2
skinparam roundcorner 10
skinparam maxmessagesize 200

box "Cliente" #LightBlue
    actor Usuario as user
end box

box "Auth" #LightGreen
    participant "Cognito" as cognito
end box

box "FIAPX API (Elysia)" #LightYellow
    participant "POST /videos" as apiCreate
    participant "GET /upload-urls" as apiUrls
    participant "POST /parts/{n}" as apiParts
    participant "POST /complete" as apiComplete
    participant "API Consumer" as apiConsumer
end box

box "AWS Storage" #Orange
    database "S3 Videos" as s3
    database "S3 Frames" as s3frames
end box

box "AWS Events" #Pink
    participant "EventBridge" as eb
    queue "SQS Multipart" as sqsMultipart
    queue "SQS Orchestrator" as sqsOrch
    queue "SQS Print" as sqsPrint
    participant "API Dest\n(SES)" as apiDestSES
end box

box "Kubernetes (Bun Runtime)" #Gray
    participant "Orchestrator\nWorker" as orch
    participant "Print Worker 1" as print1
    participant "Print Worker 2" as print2
    participant "Print Worker N" as printN
end box

box "Notifications" #LightCyan
    participant "SES\nTemplates" as ses
end box

database "ScyllaDB" as db #Gold

== 0. Autenticacao ==

user -> cognito: POST /auth/login (email)
cognito --> user: Codigo OTP (email)
user -> cognito: POST /auth/verify (codigo)
cognito --> user: JWT Token

== 1. Criar Video ==

user -> apiCreate: POST /videos\n{totalSize, duration}
activate apiCreate
apiCreate -> s3: CreateMultipartUpload
s3 --> apiCreate: uploadId
apiCreate -> db: INSERT video (CREATED)
apiCreate --> user: {videoId, uploadId, totalParts}
deactivate apiCreate

== 2. Obter URLs (Paginado) ==

loop Batch de 20 URLs
    user -> apiUrls: GET /upload-urls?start=N&limit=20
    activate apiUrls
    apiUrls -> s3: getSignedUrl (x20)
    apiUrls -> db: UPDATE status = UPLOADING
    apiUrls --> user: {urls: [...20], nextStart}
    deactivate apiUrls
end

== 3. Upload Paralelo (Presigned URLs) ==

user -> s3: PUT presigned URL (parte 1)
s3 --> user: ETag
user -> apiParts: POST /parts/1 {etag}
apiParts -> db: UPDATE part 1 (uploaded)

note over user, s3
    Upload direto no S3 (Zero proxy)
    Upload paralelo de ate 20 partes
end note

== 4. Finalizar Upload ==

user -> apiComplete: POST /complete\n{parts: [{partNumber, etag}...]}
activate apiComplete
apiComplete -> s3: CompleteMultipartUpload
s3 --> apiComplete: 200 OK
apiComplete --> user: 202 Accepted
deactivate apiComplete

== 5. Evento S3 -> SQS -> API Consumer ==

s3 -> eb: Object Created\n(CompleteMultipartUpload)
activate eb
eb -> sqsMultipart: Enfileira mensagem
deactivate eb

sqsMultipart -> apiConsumer: Poll (background)
activate apiConsumer
apiConsumer -> db: UPDATE status = UPLOADED
apiConsumer -> eb: PutEvents\n(Video Status Changed: UPLOADED)
deactivate apiConsumer

eb -> sqsOrch: Enfileira mensagem

== 6. Orchestrator (Fan-out) ==

sqsOrch -> orch: Poll (KEDA escala pod)
activate orch
orch -> orch: Calcula ranges\n(duration / 10s = N)
orch -> orch: Gera presigned URL
orch -> sqsPrint: Publica N mensagens\n{videoId, presignedUrl, startTime, endTime}
orch -> db: UPDATE totalSegments = N
deactivate orch

note over orch, sqsPrint
    Fan-out: 1 video de 100s = 10 mensagens
    Cada mensagem = 1 range de tempo
end note

== 7. Print Workers (Paralelo) ==

par Processamento Paralelo
    sqsPrint -> print1: Poll (range 0-10s)
    activate print1
    print1 -> s3: HTTP Range Request (0-10s)
    print1 -> print1: FFmpeg extract frames
    print1 -> s3frames: Upload frames
    print1 -> db: UPDATE processedSegments++
    deactivate print1
and
    sqsPrint -> print2: Poll (range 10-20s)
    activate print2
    print2 -> s3: HTTP Range Request (10-20s)
    print2 -> print2: FFmpeg extract frames
    print2 -> s3frames: Upload frames
    print2 -> db: UPDATE processedSegments++
    deactivate print2
and
    sqsPrint -> printN: Poll (range N)
    activate printN
    printN -> s3: HTTP Range Request
    printN -> printN: FFmpeg extract frames
    printN -> s3frames: Upload frames
    printN -> db: UPDATE processedSegments++
    printN -> eb: PutEvents\n(Video Status Changed: COMPLETED)
    deactivate printN
end

note over print1, printN
    Streaming: FFmpeg le via HTTP Range
    Nunca baixa video completo
    Disco: apenas frames locais (~10MB/range)
end note

== 8. Notificacao Final ==

eb -> apiDestSES: Roteia (status = COMPLETED)
apiDestSES -> ses: SendTemplatedEmail\n(VideoConcluido)
ses --> user: Email: "Seu video esta pronto!"

== Fluxo Concluido ==

note over user, db
    Video de 100s com 10 workers:
    - Upload: ~2 min
    - Orchestrator: ~1s
    - Print paralelo: ~30s (vs 5 min sequencial)
    - Total: ~2.5 min

    Zero Lambda, Zero download completo
    Custo: apenas tempo de execucao dos workers
end note

@enduml
