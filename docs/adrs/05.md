# ADR 005 - Processamento de Vídeo com Kubernetes Jobs + FFmpeg CLI

| Campo      | Valor                |
|------------|----------------------|
| Status     | Aceito               |
| Data       | 2026-01-16           |
| Autor      | Arão Freitas         |

## Contexto

O sistema processa vídeos grandes (~1h / 1GB) para extração de frames.
Para reduzir tempo, custo e uso de recursos:

- O vídeo é dividido em segmentos (ex: 30s–60s)
- Cada Kubernetes Job processa apenas um trecho
- Os frames são enviados diretamente ao S3
- Processamento pesado (CPU/IO)
- Uso de disco
- Execução potencialmente longa
- Escalabilidade horizontal
- Baixo custo operacional
- Baixa complexidade de manutenção

Todos os cenários avaliados usam Kubernetes Jobs como runtime:
- FFmpeg CLI
- Node.js + SDK
- Go + SDK
- Rust + bindings
- Lambda-style runtime em container

O objetivo é escolher a stack mais eficiente, barata e simples para o Job.

## Decisão

Usar FFmpeg CLI + AWS CLI em Jobs Kubernetes para processar segmentos de vídeo.

Fluxo do Job:

1 - Baixa apenas o chunk necessário

2 - Executa FFmpeg no trecho

3 - Gera frames

4 - Envia ao S3

5 - Finaliza

## Justificativa Técnica

### Processamento por segmentos

#### Vantagens:

- Menor tempo por Job
- Menor consumo de CPU/RAM
- Paralelismo natural
- Falhas isoladas
- Retry por trecho
- Escala linear

#### Kubernetes Jobs (baseline):

- Sem limite de tempo
- Uso completo de disco
- Controle de paralelismo
- Retry + backoff
- Escalabilidade horizontal
- Custo previsível

#### FFmpeg CLI (diferencial):

- Implementação nativa
- Máxima performance
- Menor overhead
- Menor uso de memória
- Menos dependências
- Menos código
- Melhor custo

### Comparativo: CLI vs Node vs Go vs Rust

(Todos processando apenas segmentos)

| Critério | FFmpeg CLI | Node.js | Go | Rust |
|----------|------------|---------|-----|------|
| Performance | 5 | 2 | 3 | 4 |
| Overhead | Mínimo | Alto | Médio | Baixo |
| Memória | Baixa | Alta | Média | Média |
| Tempo por chunk | Menor | Maior | Médio | Médio |
| Complexidade | Baixa | Média | Média | Alta |
| Manutenção | Baixa | Alta | Média | Alta |
| Código | Mínimo | Alto | Médio | Alto |
| Custo | Menor | Maior | Médio | Médio |

### Conclusão

Mesmo em processamento segmentado, as linguagens só orquestram FFmpeg. O CLI elimina camadas inúteis.

### Premissas de Custo (us-east-1)

| Parâmetro | Valor |
|-----------|-------|
| Instância | c6a.large |
| vCPU | 2 |
| RAM | 4 GB |
| Custo/h | $0.068 |
| Custo/min | $0.00113 |

### Consumo por Job (segmento ~60s)

| Stack | Duração | CPU/RAM | Custo |
|-------|---------|---------|-------|
| FFmpeg CLI | 20s | 0.5 vCPU / 256MB | $0.00038 |
| Go + SDK | 30s | 0.8 vCPU / 512MB | $0.00075 |
| Rust + bindings | 28s | 0.8 vCPU / 512MB | $0.00070 |
| Node + SDK | 35s | 1 vCPU / 768MB | $0.0011 |

### 10.000 segmentos/mês

| Stack | Custo |
|-------|-------|
| FFmpeg CLI | $3.80 |
| Rust | $7.00 |
| Go | $7.50 |
| Node | $11.00 |
## Consequências

### Positivas

- Jobs curtos e baratos
- Melhor paralelismo
- Falhas isoladas
- Escala horizontal eficiente
- Menor custo total
- Arquitetura simples
- Menos código

### Negativas

- Orquestração de chunks é responsabilidade da API
- Requer controle de ordem/merge se necessário
- Logs distribuídos por segmento

## Alternativas Consideradas

(Todas usando Jobs Kubernetes e processamento por segmento)

1. **Node.js + SDK**: Descartado por overhead de runtime, maior uso de memória, código mais verboso e sem ganho técnico
2. **Go + SDK**: Descartado por complexidade extra, ainda depende do FFmpeg e ganho marginal
3. **Rust + bindings**: Descartado por curva de aprendizado, complexidade operacional e ganho irrelevante
4. **Lambda-style runtime**: Descartado por build mais complexo, sem vantagem em Jobs e overhead desnecessário

## Referências

- [FFmpeg Documentation](https://ffmpeg.org/documentation.html)
- [Kubernetes Jobs](https://kubernetes.io/docs/concepts/workloads/controllers/job/)
- [AWS EC2 Pricing](https://aws.amazon.com/ec2/pricing/)
- [KEDA](https://keda.sh/docs/)